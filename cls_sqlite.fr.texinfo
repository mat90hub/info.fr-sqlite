\input texinfo   @c -*-mode: texinfo; coding: utf-8-unix; -*-
@c %**start of header
@setfilename cls_sqlite.fr.info
@settitle L’interface ligne de commande de SQLite
@c %**end of header

@documentencoding UTF-8
@c typographie française :    «   » …

@direntry
* Console SQLite: (cls_sqlite.fr).         Console pour SQLite
@end direntry


@set xref-automatic-section-title

@set TITLE L’interface ligne de commande de SQLite

@copying
Ce fichier est une traduction de la page html pour la documentation
officielle de l’interface en ligne de commande de SQLite :
@url{https://www.sqlite.org/cli.html}.  Le site est régulièrement mis à
jour, la version traduite date de juin 2024.
@end copying

@paragraphindent 0

@iftex
@set DOCUMENT article
@set CHAPTER chapter
@set SECTION section
@end iftex

@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set SECTION minor node
@end ifinfo

@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set SECTION section
@end ifhtml


@titlepage
@title @value{TITLE}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage


@ifnottex
@node Top
@top SQLITE en ligne de commande
Ce manuel explique comment interagir avec une base de données SQLite dans
une console en utilisant la commande @code{sqlite3}.
@end ifnottex


@contents

@c 1
@node Pour commencer
@chapter Pour commencer
@anchor{#getting_started}

Le projet SQLite fournit un programme de ligne de commande simple
@code{sqlite3} (ou @code{sqlite3.exe} sous Windows) qui permet à
l’utilisateur de saisir et d’exécuter des instructions SQL sur une base
de données SQLite ou sur une archive ZIP. Ce document fournit une
introduction sur la façon d’utiliser le programme sqlite3 .

Pour commencer, lancez le programme sqlite3 en tapant @code{sqlite3}
dans un shell, éventuellement suivi du nom du fichier contenant la base
de données SQLite(ou l’archive ZIP). Si le fichier nommé n’existe pas,
un nouveau fichier de base de données portant le nom donné sera créé
automatiquement. Si aucun fichier de base de données n’est spécifié sur
la ligne de commande, une base de données temporaire est créée et
automatiquement supprimée en fin d’exécution du programme
@code{sqlite3}.

Au démarrage, le programme @code{sqlite3} affichera un bref message de
bannière puis vous invitera à saisir du SQL. Tapez les instructions SQL
(terminées par un point-virgule), appuyez sur "Entrée" et le code SQL
sera exécuté.

Par exemple, pour créer une nouvelle base de données SQLite
nommée @code{ex1} avec une seule table nommée @code{tbl1}, vous pouvez
procéder comme suit :

@example
$ sqlite3 ex1
SQLite version 3.36.0 2021-06-18 18:36:39
Enter ".help" for usage hints.
sqlite> create table tbl1(one varchar(10), two smallint);
sqlite> insert into tbl1 values('hello!',10);
sqlite> insert into tbl1 values('goodbye', 20);
sqlite> select * from tbl1;
hello!|10
goodbye|20
sqlite>
@end example

Terminez le programme sqlite3 en tapant le caractère de fin de
fichier de votre système (généralement un @key{CTRL}-D). Utilisez le
caractère d’interruption (généralement un @key{CTRL}-C) pour arrêter une
instruction SQL qui durt trop longtemps.

Assurez-vous de taper un point-virgule à la fin de chaque commande SQL !
Le programme sqlite3 recherche un point-virgule pour savoir si
l’instruction SQL est terminée. Si vous omettez le point-virgule,
@code{sqlite3} affiche une invite de suite et attend que vous
saisissiez plus de texte pour terminer l’instruction SQL en court. Cette
fonctionnalité vous permet de saisir des commandes SQL qui s’étendent
sur plusieurs lignes.  Par exemple:

@example
sqlite> CREATE TABLE tbl2 ( 
   ...>   f1 varchar(30) primary key,
   ...>   f2 text,
   ...>   f3 real
   ...> );
sqlite>
@end example


@c 2
@node Démarrage en deux clics sous Windows
@chapter Démarrage en deux clics sous Windows
@anchor{#double_click_startup_on_windows}

Les utilisateurs de Windows peuvent double-cliquer sur l’icône
@code{sqlite3.exe} pour que le shell de ligne de commande affiche une
fenêtre de terminal exécutant SQLite. Cependant, comme un
double-clic démarre @code{sqlite3.exe} sans arguments de ligne de
commande, aucun fichier de base de données n’aura été spécifié, donc
SQLite utilisera une base de données temporaire qui sera
supprimée à la fin de la session. Pour utiliser un fichier de disque
persistant comme base de données, entrez la commande @code{.open}
immédiatement après le démarrage de la fenêtre du terminal :

@example
SQLite version 3.36.0 2021-06-18 18:36:39
Enter ".help" for usage hints.in        
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> .open ex1.db
sqlite>
@end example

L’exemple ci-dessus provoque l’ouverture et l’utilisation du fichier de
base de données nommé @file{ex1.db}. Le fichier "ex1.db" est créé s’il
n’existe pas auparavant. Vous souhaiterez peut-être utiliser un chemin
d’accès complet pour vous assurer que le fichier se trouve dans le
répertoire dans lequel vous pensez qu’il se trouve. Utilisez des barres
obliques comme caractère de séparation de répertoire. En d’autres
termes, utilisez @file{c:/work/ex1.db}, et non @file{c:\work\ex1.db}.

Alternativement, vous pouvez créer une nouvelle base de données en
utilisant le stockage temporaire par défaut, puis enregistrer cette base
de données dans un fichier disque à l’aide de la commande @code{.save} :

@example
SQLite version 3.36.0 2021-06-18 18:36:39
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> ... ici on entre plusieurs commandes SQL  ...
sqlite> ... en oublient d’ouvrir une base  ...
sqlite> .save ex1.db
sqlite>
@end example

Soyez prudent lorsque vous utilisez la commande @code{.save} car elle
écrasera tous les fichiers de base de données préexistants portant le
même nom sans demander de confirmation. Comme pour la commande @code{.open},
vous souhaiterez peut-être utiliser un chemin d’accès complet avec des
séparateurs de répertoire par barre oblique pour éviter toute ambiguïté.


@c 3
@node Les commandes point de sqlite3
@chapter Les commandes point de sqlite3
@anchor{#special_commands_to_sqlite3_dot_commands_}

La plupart du temps, @code{sqlite3} lit simplement les lignes d’entrée
et les transmet à la bibliothèque SQLite pour exécution. Mais
les lignes d’entrée commençant par un point (@code{.}) sont interceptées
et interprétées par le programme @code{sqlite3} lui-même. Ces
@emph{commandes point} sont généralement utilisées pour modifier le
format de sortie des requêtes ou pour exécuter certaines instructions de
requête préemballées. À l’origine, il n’y avait que quelques commandes
par points, mais au fil des années, de nombreuses nouvelles
fonctionnalités se sont accumulées, si bien qu’il en existe aujourd’hui
plus de 60.

Pour obtenir une liste des commandes point disponibles, vous pouvez
saisir @code{.help} sans argument. Ou entrez @code{.help TOPIC} pour des
informations détaillées sur @code{TOPIC}. 

Voici la liste de ces options, avec l’explication traduite en français.

@multitable @columnfractions .31 .69

@item @code{.archive ...}
@tab Gérer les archives SQL

@item @code{.auth ON|OFF}
@tab Afficher les rappels de l’autorisateur

@item @code{.backup ?DB? FILE}
@tab Sauvegarder @code{DB} (par défaut "main") dans @code{FILE}

@item @code{.bail on|off}
@tab Arrêter après une erreur. Par défaut @code{OFF}

@item @code{.binary on|off}
@tab Activer ou désactiver la sortie binaire. Par défaut @code{OFF}

@item @code{.cd DIRECTORY}
@tab Changer le répertoire de travail pour @code{DIRECTORY}

@item @code{.changes on|off}
@tab Afficher le nombre de lignes modifiées

@item @code{.check GLOB}
@tab Échouer si la sortie depuis @code{.testcase} ne correspond pas

@item @code{.clone NEWDB}
@tab Clôner les données dans @code{NEWDB} à partir de la base de données existante

@item @code{.databases}
@tab Lister les noms et fichiers des bases de données attachées

@item @code{.dbconfig ?op? ?val?}
@tab Lister ou changer les options de @code{sqlite3_db_config()}

@item @code{.dbinfo ?DB?}
@tab Afficher les informations de statut sur la base de données

@item @code{.dump ?TABLE? ...}
@tab Traduire tout le contenu de la base de données en instruction SQL

@item @code{.echo on|off}
@tab Activer ou désactiver l’écho des commandes

@item @code{.eqp on|off|full}
@tab Activer ou désactiver la plan @code{EXPLAIN QUERY PLAN}

@item @code{.excel}
@tab Afficher la sortie de la prochaine commande dans une feuille de calcul

@item @code{.exit ?CODE?}
@tab Quitter ce programme avec le code de retour @code{CODE}

@item @code{.expert}
@tab (EXPÉRIMENTAL) Suggérer des index pour les requêtes spécifiées

@item @code{.fullschema ?--indent?}
@tab Afficher le schéma et le contenu des tables @code{sqlite_stat}

@item @code{.headers on|off}
@tab Activer ou désactiver l’affichage des en-têtes

@item @code{.help ?-all? ?PATTERN?}
@tab Afficher le texte d'aide pour @code{PATTERN}

@item @code{.import FILE TABLE}
@tab Importer les données de @code{FILE} dans @code{TABLE}

@item @code{.imposter INDEX TABLE}
@tab Créer une @code{TABLE} @code{.imposter} sur l’index @code{INDEX}

@item @code{.indexes ?TABLE?}
@tab Afficher les noms des index

@item @code{.iotrace FILE}
@tab Activer la journalisation de diagnostic d'E/S dans FILE

@item @code{.limit ?LIMIT? ?VAL?}
@tab Afficher ou changer la valeur d'un @code{SQLITE_LIMIT}

@item @code{.lint OPTIONS}
@tab Signaler les problèmes potentiels du schéma

@item @code{.load FILE ?ENTRY?}
@tab Charger une bibliothèque d'extensions

@item @code{.log FILE|off}
@tab Activer ou désactiver la journalisation. FILE peut être stderr/stdout

@item @code{.mode MODE ?TABLE?}
@tab Définir le mode de sortie

@item @code{.nullvalue STRING}
@tab Utiliser STRING à la place des valeurs @code{NULL}

@item @code{.once (-e|-x|FILE)}
@tab Sortie de la prochaine commande SQL uniquement dans @code{FILE}

@item @code{.open ?OPTIONS? ?FILE?}
@tab Fermer la base de données existante et rouvrir @code{FILE}

@item @code{.output ?FILE?}
@tab Envoyer la sortie vers @code{FILE} ou stdout si @code{FILE} est omis

@item @code{.print STRING...}
@tab Imprimer la chaîne de caractères littérale @code{STRING}

@item @code{.prompt MAIN CONTINUE}
@tab Remplacer les invites standard

@item @code{.quit}
@tab Quitter ce programme

@item @code{.read FILE}
@tab Lire l’entrée de @code{FILE}

@item @code{.restore ?DB? FILE}
@tab Restaurer le contenu de @code{DB} (par défaut "main") à partir de @code{FILE}

@item @code{.save FILE}
@tab Écrire la base de données en mémoire dans @code{FILE}

@item @code{.scanstats on|off}
@tab Activer ou désactiver les métriques @code{sqlite3_stmt_scanstatus()}

@item @code{stats ?on/?off}
@tab Montre les statistiques ou les arrête

@item @code{.schema ?PATTERN?}
@tab Afficher les déclarations CREATE correspondant à @code{PATTERN}

@item @code{.selftest ?OPTIONS?}
@tab Exécuter les tests définis dans la table @code{SELFTEST}

@item @code{.separator COL ?ROW?}
@tab Changer les séparateurs de colonne et de ligne

@item @code{.session ?NAME? CMD ...}
@tab Créer ou contrôler des sessions

@item @code{.sha3sum ...}
@tab Calculer un hachage SHA3 du contenu de la base de données

@item @code{.shell CMD ARGS...}
@tab Exécuter @code{CMD ARGS...} dans un shell système

@item @code{.show}
@tab Afficher les valeurs actuelles pour divers paramètres

@item @code{.stats ?on|off?}
@tab Afficher les statistiques ou activer/désactiver les statistiques

@item @code{.system CMD ARGS...}
@tab Exécuter @code{CMD ARGS...} dans un environnement de shell

@item @code{.tables ?TABLE?}
@tab Lister les noms des tables correspondant au modèle @code{LIKE TABLE}

@item @code{.testcase NAME}
@tab Commencer à rediriger la sortie vers @file{testcase-out.txt}

@item @code{.timeout MS}
@tab Essayer d'ouvrir les tables verrouillées pendant @code{MS} millisecondes

@item @code{.timer on|off}
@tab Activer ou désactiver le chronomètre SQL

@item @code{.trace FILE|off}
@tab Afficher chaque instruction SQL au fur et à mesure de son exécution

@item @code{.vfsinfo ?AUX?}
@tab Informations sur le Système de fichiers Virtuels (VFS) de premier niveau

@item @code{.vfslist}
@tab Lister tous les Systèmes de fichiers Virtuels (VFS) disponibles

@item @code{.vfsname ?AUX?}
@tab Imprimer le nom de la pile du Systèmes de fichiers Virtuels (VFS)

@item @code{.width NUM1 NUM2 ...}
@tab Définir les largeurs de colonne pour le mode @code{column}

@end multitable


@c 4
@node Règles pour les commandes point
@chapter Règles pour les commandes point
@anchor{#rules_for_dot_commands_sql_and_more}

@menu
* Structure d’une ligne::
* Arguments des commandes point::
* Exécution des commandes point::
@end menu

@c 4.1
@node Structure d’une ligne
@section Structure d’une ligne
@anchor{#line_structure}

L’entrée de la ligne de commande d’interface est analysée en une
séquence composée de :

@itemize
@item
Instructions SQL ;
@item
commandes point;
@item
Commentaires de la ligne de commande d’interface.
@end itemize

Les instructions SQL ont des formes libres et peuvent être
réparties sur plusieurs lignes, avec des espaces ou des commentaires
SQL intégrés n’importe où. Ils se terminent soit par un
@code{;} caractère à la fin d’une ligne de saisie, ou un caractère
@code{/} ou le mot @code{go} sur une ligne seul.  Lorsqu’il n’est pas à
la fin d’une ligne de saisie, le @code{;} le caractère agit pour séparer
les instructions SQL. Les espaces de fin sont ignorés à des fins de
terminaison.

Une commande point a une structure plus restrictive :

@itemize
@item
Il doit commencer par son @code{.} dans la marge de gauche sans espace
précédent.
@item
Il doit être entièrement contenu sur une seule ligne d’entrée.
@item
Cela ne peut pas se produire au milieu d’une instruction SQL
ordinaire.  En d’autres termes, cela ne peut pas se produire à une
invite de continuation.
@item
Il n’y a pas de syntaxe de commentaire pour les commandes point.
@end itemize

L’interface en ligne de commande accepte également les commentaires sur
une ligne entière commençant par un caractère @code{#} et s’étendant
jusqu’à la fin de la ligne. Il ne faut aucun espace avant le caractère
@code{#}.


@c 4.2
@node Arguments des commandes point
@section Arguments des commandes point
@anchor{#dot_command_arguments}

Les arguments passés aux commandes point sont analysés en commençant
par la queue de la commande en suivant ces règles :

@enumerate 
@item
La nouvelle ligne de fin et tout autre espace de fin sont supprimés ;

@item
Les espaces immédiatement après le nom de la commande point ou toute
limite de fin d’entrée d’argument sont ignorés ;

@item
Une entrée d’argument commence par n’importe quel caractère autre qu’un
espace ;

@item
Une entrée d’argument se termine par un caractère qui dépend ainsi de
son caractère principal :

@itemize
@item
pour un guillemet simple de début (@code{'}), un guillemet simple fait
office de délimiteur de fin ;
@item
pour un guillemet double (@code{"}), un guillemet double non échappé
fait office de délimiteur de fin ;
@item
pour tout autre caractère principal, le délimiteur de fin est n’importe
quel espace ;
@item
la commande @code{tail} end agit comme délimiteur de fin pour tout
argument ;
@item
Dans une entrée d’argument entre guillemets doubles, un guillemet double
avec une barre oblique inverse fait partie de l’argument plutôt que de
son guillemet final ;
@item
Dans un argument entre guillemets doubles, la traduction traditionnelle
de la séquence d’échappement de la chaîne C littérale et de la barre
oblique inverse est effectuée ;
@item
Les délimiteurs d’entrée d’argument (les guillemets ou les espaces) sont
ignorés pour produire l’argument passé.
@end itemize

@end enumerate

@c 4.3
@node Exécution des commandes point
@section Exécution des commandes point
@anchor{#dot_command_execution}

Les commandes point sont interprétées par le programme de ligne de
commande sqlite3.exe, et non par SQLite lui-même. Ainsi, aucune des
commandes point ne fonctionnera comme argument pour les interfaces
SQLite telles que  @code{sqlite3_prepare()} ou @code{sqlite3_exec()}.


@c 5
@node Modification des formats de sortie
@chapter Modification des formats de sortie
@anchor{#changing_output_formats}

Le programme @code{sqlite3} est capable d’afficher les résultats d’une requête
dans 14 formats de sortie différents :

@itemize
@item @code{ascii}
@item @code{box}
@item @code{csv}
@item @code{column}
@item @code{html  }
@item @code{insert}
@item @code{json}
@item @code{line}
@item @code{list}
@item @code{markdown}
@item @code{quote}
@item @code{table}
@item @code{tabs}
@item @code{tcl}
@end itemize

Vous pouvez utiliser la commande point @code{.mode} pour basculer entre ces
formats de sortie. Le mode de sortie par défaut est @code{list}. En mode
@code{list}, chaque ligne d’un résultat de requête est écrite sur une ligne de
sortie et chaque colonne de cette ligne est séparée par une chaîne de
séparation spécifique. Le séparateur par défaut est un symbole de barre
verticale (@code{|}). Le mode liste est particulièrement utile lorsque vous
souhaitez envoyer le résultat d’une requête à un autre programme (tel
qu’AWK) pour un traitement supplémentaire.

@example
sqlite> .mode list 
sqlite> select * from tbl1 ;
bonjour!|10
au revoir|20
sqlite>
@end example

Tapez @code{.mode} sans argument pour afficher le mode actuel :

@example
sqlite> .mode
mode de sortie actuel : liste
sqlite>
@end example

Utilisez la commande point @code{.separator} pour changer le séparateur. Par
exemple, pour remplacer le séparateur par une virgule et un espace, vous
pouvez procéder comme suit :

@example
sqlite> .separator ", " 
sqlite> select * from tbl1 ;
bonjour!, 10
au revoir, 20
sqlite>
@end example

La prochaine commande @code{.mode} pourrait réinitialiser le @code{.separator} à
une valeur par défaut (en fonction de ses arguments). Vous devrez donc
probablement répéter la commande @code{.separator} chaque fois que vous
changez de mode si vous souhaitez continuer à utiliser un séparateur non
standard.

En mode @code{quote}, la sortie est formatée sous forme d’instruction
SQL littérale. Les chaînes sont placées entre guillemets simples et les
guillemets simples internes sont échappés en les doublant. Les blobs
sont affichés en notation littérale hexadécimale (Ex : x'abcd'). Les
nombres sont affichés sous forme de texte ASCII et les valeurs
@code{NULL} sont affichées sous forme de @code{NULL}. Toutes les
colonnes sont séparées les unes des autres par une virgule (ou tout
autre caractère sélectionné à l’aide de @code{.separator}).

@example
sqlite> .mode quote 
sqlite> select * from tbl1 ;
'bonjour !',10
'au revoir',20
sqlite>
@end example

En mode @code{line}, chaque colonne d’une ligne de la base de données est
affichée seule sur une ligne. Chaque ligne comprend le nom de la
colonne, un signe égal et les données de la colonne. Les enregistrements
successifs sont séparés par une ligne vierge. Voici un exemple de sortie
en mode @code{line} :

@example
sqlite> .mode line 
sqlite> select * from tbl1 ;
un = bonjour !
deux = 10

un = au revoir
deux = 20
sqlite>
@end example

En mode colonne, chaque enregistrement est affiché sur une ligne
distincte avec les données alignées en colonnes. Par exemple:

@example
sqlite> colonne .mode 
sqlite> select * from tbl1 ;
un deux
--------- ---
Bonjour! dix
au revoir 20
sqlite>
@end example

En mode @code{column} (et également en modes @code{box}, @code{table} et
@code{markdown}) la largeur des colonnes s’ajuste automatiquement. Mais
vous pouvez remplacer cela en fournissant une largeur spécifiée pour
chaque colonne à l’aide de la commande @code{.width}. Les arguments de
@code{.width} sont des entiers qui correspondent au nombre de caractères
à consacrer à chaque colonne. Les nombres négatifs signifient justifier
à droite.

Ainsi :

@example
sqlite> .width 12 -6 
sqlite> select * from tbl1 ;
un deux
------------ ------
Bonjour! dix
au revoir 20
sqlite>
@end example

Une largeur de 0 signifie que la largeur de la colonne est choisie
automatiquement. Les largeurs de colonnes non spécifiées deviennent
nulles. Par conséquent, la commande @code{.width} sans argument réinitialise
toutes les largeurs de colonnes à zéro et provoque donc la détermination
automatique de toutes les largeurs de colonnes.

Le mode « colonne » est un format de sortie tabulaire. Les autres
formats de sortie tabulaires sont «@ box@ », «@ markdown@ » et
«@ table@ » :

@ifnottex
@example
sqlite> .width 
sqlite> .mode markdown 
sqlite> select * from tbl1 ;
|    un     | deux |
|---------- |----- |
| Bonjour!  |  10  |
| au revoir |  20  |
sqlite> .mode table 
sqlite> select * from tbl1 ;
+-----------+------+
|    un     | deux |
+-----------+------+
| Bonjour!  |  10  |
| au revoir |  20  |
+-----------+------+
sqlite> .mode box 
sqlite> select * from tbl1 ;
┌───────────┬─────┐
│    un     │deux │
├───────────┼─────┤
│ bonjour ! │ 10  │
│ au revoir │ 20  │
└───────────┴─────┘
sqlite>
@end example
@end ifnottex

@iftex
@example
sqlite> .width 
sqlite> .mode markdown 
sqlite> select * from tbl1 ;
|    un     | deux |
|---------- |----- |
| Bonjour!  |  10  |
| au revoir |  20  |
sqlite> .mode table 
sqlite> select * from tbl1 ;
+-----------+------+
|    un     | deux |
+-----------+------+
| Bonjour!  |  10  |
| au revoir |  20  |
+-----------+------+
sqlite> .mode box 
sqlite> select * from tbl1 ;
+-----------+-----+
|    un     |deux |
+-----------+-----+
| bonjour ! | 10  |
| au revoir | 20  |
+-----------+-----+
sqlite>
@end example
@end iftex


Les modes en colonnes ont quelques options supplémentaires pour
contrôler le formatage. L’option @code{--wrap @emph{N} } (où @emph{N} est un
entier) amène les colonnes à envelopper le texte qui dépasse N
caractères. Le wrapping est désactivé si N est nul.

@ifnottex
@example
sqlite> insert into tbl1 values('Le renard saute par-dessus le chien.',90); 
sqlite> .mode box --wrap 30 
sqlite> select * from tbl1 où deux>50 ;
┌──────────────────────────────────────┬─────┐
│               un                     │deux │
├──────────────────────────────────────┼─────┤
│ Le renard saute par-dessus le chien. │ 90  │
└──────────────────────────────────────┴─────┘
sqlite>
@end example
@end ifnottex

@iftex
sqlite> insert into tbl1 values('Le renard saute par-dessus le chien.',90); 
sqlite> .mode box --wrap 30 
sqlite> select * from tbl1 où deux>50 ;
+--------------------------------------+-----+
|               un                     |deux |
+--------------------------------------+-----+
| Le renard saute par-dessus le chien. | 90  |
+--------------------------------------+-----+
sqlite>
@end iftex

Le retour à la ligne se produit après exactement @emph{N} caractères,
qui peuvent se trouver au milieu d’un mot. Pour revenir à la limite d’un
mot, ajoutez l’option @code{--wordwrap on} (ou simplement @code{-ww} pour faire
court) :

@ifnottex
@example
sqlite> .mode box --wrap 30 -ww 
sqlite> select * from tbl1 où deux>50 ;
┌──────────────────────────────────────┬──────┐
│             un                       │ deux │
├──────────────────────────────────────┼──────┤
│ Le renard saute par-dessus le chien. │  90  │
└──────────────────────────────────────┴──────┘
sqlite>
@end example
@end ifnottex

@iftex
@example
sqlite> .mode box --wrap 30 -ww 
sqlite> select * from tbl1 où deux>50 ;
+--------------------------------------+------+
|             un                       | deux |
+--------------------------------------+------+
| Le renard saute par-dessus le chien. |  90  |
+--------------------------------------+------+
sqlite>
@end example
@end iftex


L’option @code{--quote} fait que les résultats de chaque colonne sont
cités comme une chaîne SQL littérale, comme dans le mode
@code{quote}. Consultez l’aide en ligne pour des options
supplémentaires.

La commande @code{.mode box --wrap 60 --quote} est si utile pour les requêtes
de base de données à usage général qu’elle reçoit son propre alias. Au
lieu de taper toute cette commande de 27 caractères, vous pouvez
simplement dire @code{.mode qbox}.

Un autre mode de sortie utile est @code{insertion}. En mode insertion,
la sortie est formatée pour ressembler aux instructions @code{SQL
INSERT}.  Utilisez le mode insertion pour générer du texte qui pourra
ensuite être utilisé pour saisir des données dans une autre base de
données.

Lors de la spécification du mode d’insertion, vous devez donner un
argument supplémentaire qui est le nom de la table dans laquelle
insérer. Par exemple:

@example
sqlite> .mode insert new_table 
sqlite> select * from tbl1 où deux<50 ;
INSERT INTO "new_table" VALUES('bonjour',10);
INSERT INTO "new_table" VALUES('goodbye',20);
sqlite>
@end example

Les autres modes de sortie incluent @code{csv}, @code{json} et @code{tcl}.
Essayez-les vous-même pour voir ce qu’ils font.


@c 6
@node Requête sur le schéma de la base de données
@chapter Requête sur le schéma de la base de données
@anchor{#querying_the_database_schema}

Le programme @code{sqlite3} fournit plusieurs commandes pratiques et utiles
pour consulter le schéma de la base de données. Il n’y a rien de ce que
font ces commandes qui ne puisse être fait par d’autres moyens. Ces
commandes sont fournies uniquement à titre de raccourci.

Par exemple, pour voir une liste des tables de la base de données, vous
pouvez saisir @code{.tables}.

@example
sqlite> .tables
tbl1 tbl2
sqlite>
@end example

La commande @code{.tables} est similaire à la définition du mode
@code{list} puis à l’exécution de la requête suivante :

@example
SELECT name FROM sqlite_master 
WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%'
ORDER BY 1
@end example

Mais la commande @code{.tables} fait plus. Il interroge la table
@code{sqlite_master} pour toutes les bases de données attachées, pas
seulement la base de données principale. Et il organise sa sortie en
colonnes soignées.

La commande @code{.indexes} fonctionne de la même manière pour lister tous
les index. Si la commande @code{.indexes} reçoit un argument qui est le nom
d’une table, alors elle affiche uniquement les index de cette table.

La commande @code{.schema} affiche le schéma complet de la base de données,
ou pour une seule table si un argument facultatif de nom de table est
fourni :

@example
sqlite> .schéma
créer la table tbl1 (un varchar (10), deux smallint)
CRÉER UNE TABLE tbl2 (
  clé primaire f1 varchar(30),
  texte f2,
  f3 réel
);
sqlite> .schéma tbl2
CRÉER UNE TABLE tbl2 (
  clé primaire f1 varchar(30),
  texte f2,
  f3 réel
);
sqlite>
@end example

La commande @code{.schema} est à peu près la même que pour définir le mode
liste, puis saisir la requête suivante :

@example
SELECT sql FROM sqlite_schema
ORDER BY tbl_name, tapez DESC, nom
@end example

Comme pour @code{.tables}, la commande @code{.schema} affiche le schéma
de toutes les bases de données attchées. Si vous souhaitez uniquement
voir le schéma d’une seule base de données (peut-être @code{main}), vous
pouvez ajouter un argument à @code{.schema} pour restreindre sa sortie :

@example
sqlite> .schema principal.*
@end example

La commande @code{.schema} peut être complétée par l’option @code{--indent},
auquel cas elle tente de reformater les différentes instructions CREATE
du schéma afin qu’elles soient plus facilement lisibles par les humains.

La commande @code{.databases} affiche une liste de toutes les bases de
données ouvertes dans la connexion actuelle. Il y en aura toujours au
moins deux. La première est la @emph{principale}, la base de données
d’origine ouverte. La seconde est appelée @emph{temp}, la base de
données utilisée pour les tables temporaires. Des bases de données
supplémentaires peuvent être répertoriées pour les bases de données
attachées à l’aide de l’instruction @code{ATTACH}. La première colonne
de sortie est le nom avec lequel la base de données est attachée et la
deuxième colonne de résultat est le nom du fichier externe. Il peut y
avoir une troisième colonne de résultat qui sera soit @code{r/o} soit
@code{r/w} selon que le fichier de base de données est en lecture seule
ou en lecture-écriture.  Et il pourrait y avoir une quatrième colonne de
résultats affichant le résultat de @code{sqlite3_txn_state()} pour ce
fichier de base de données.

@example
sqlite> .databases
@end example

La commande point @code{.fullschema} fonctionne comme la commande
@code{.schema} dans la mesure où elle affiche l’intégralité du schéma de
la base de données. Mais @code{.fullschema} inclut également les dumps
des tables de statistiques @code{sqlite_stat1}, @code{sqlite_stat3} et
@code{sqlite_stat4}, si elles existent. La commande @code{.fullschema}
fournit normalement toutes les informations nécessaires pour recréer
exactement un plan de requête pour une requête spécifique. Lorsqu’ils
signalent des problèmes suspectés avec le planificateur de requêtes
SQLite à l’équipe de développement SQLite, les
développeurs sont priés de fournir la sortie @code{.fullschema} complète
dans le cadre du rapport de problème. Notez que les tables
@code{sqlite_stat3} et @code{sqlite_stat4} contiennent des échantillons
d’entrées d’index et peuvent donc contenir des données
sensibles. N’envoyez donc pas la sortie @code{.fullschema} d’une base de
données propriétaire sur un canal public.


@c 7
@node Ouverture des fichiers de base de données
@chapter Ouverture des fichiers de base de données
@anchor{#opening_database_files}

La commande @code{.open} ouvre une nouvelle connexion à la base de données,
après avoir d’abord fermé la commande de base de données précédemment
ouverte. Dans sa forme la plus simple, la commande @code{.open} invoque
simplement @code{sqlite3_open()}

sur le fichier nommé comme argument. Utilisez le nom @code{:memory:} pour
ouvrir une nouvelle base de données en mémoire qui disparaît lorsque la
CLI se ferme ou lorsque la commande @code{.open} est à nouveau exécutée. Ou
n’utilisez aucun nom pour ouvrir une base de données privée et
temporaire sur disque qui disparaîtra également à la sortie ou à
l’utilisation de @code{.open}.

Si l’option @code{--new} est incluse avec @code{.open}, alors la base de
données est réinitialisée avant d’être ouverte. Toutes les données
antérieures sont détruites. Il s’agit d’un écrasement détruisant les
données antérieures et aucune confirmation n’est demandée, utilisez donc
cette option avec précaution.

L’option @code{--readonly} ouvre la base de données en mode lecture seule.
L’écriture sera interdite.

L’option @code{--deserialize} entraîne la lecture de l’intégralité du
contenu du fichier sur disque en mémoire, puis son ouverture en tant que
base de données en mémoire à l’aide de l’interface
@code{sqlite3_deserialize()}. Bien entendu, cela nécessitera beaucoup de
mémoire si vous disposez d’une grande base de données. De plus, toutes
les modifications que vous apportez à la base de données ne seront pas
enregistrées sur le disque, sauf si vous les enregistrez explicitement à
l’aide des commandes @code{.save} ou @code{.backup}.

L’option @code{--append} entraîne l’ajout de la base de données
SQLite à un fichier existant plutôt que de fonctionner comme un
fichier autonome.  Voir l’extension @file{appendvfs} pour plus
d’informations.

L’option @code{--zip} fait que le fichier d’entrée spécifié est interprété
comme une archive @code{ZIP} plutôt que comme un fichier de base de données
SQLite.

L’option @code{--hexdb} permet de lire le contenu de la base de données à
partir des lignes d’entrée suivantes au format hexadécimal, plutôt qu’à
partir d’un fichier séparé sur le disque. L’outil de ligne de commande
@code{dbtotxt} peut être utilisé pour générer le texte approprié pour une
base de données. L’option @code{--hexdb} est destinée à être utilisée par les
développeurs SQLite à des fins de test. Nous ne connaissons aucun cas
d’utilisation de cette option en dehors des tests et du développement
internes de SQLite.

@c 8
@node Redirection des E/S
@chapter Redirection des E/S
@anchor{#redirecting_i_o}

@menu
* Écrire les résultats dans un fichier::
* Lire SQL à partir d’un fichier::
* Fonctions d’E/S sur les fichiers::
* La fonction SQL edit::
* Importation de fichiers au format CSV ou autres formats::
* Exporter au format CSV::
@end menu

@c 8.1
@node Écrire les résultats dans un fichier
@section Écrire les résultats dans un fichier
@anchor{#writing_results_to_a_file}

Par défaut, @code{sqlite3} envoie les résultats de la requête vers la sortie
standard. Vous pouvez modifier cela à l’aide des commandes
@code{.output} et @code{.once}. Mettez simplement le nom d’un fichier de
sortie comme argument dans @code{.output} et tous les résultats des
requêtes ultérieures seront écrits dans ce fichier. Ou utilisez la
commande @code{.once} au lieu de @code{.output} et la sortie ne sera
redirigée que pour que la commande suivante et ensuite les autres
reviendront à la console. Utilisez @code{.output} sans argument pour
recommencer à écrire sur la sortie standard. Par exemple:

@example
sqlite> .mode list 
sqlite> .separator | 
sqlite> .output test_file_1.txt 
sqlite> select * from tbl1 ; 
sqlite> .exit 
$ cat test_file_1.txt
bonjour|10
au revoir|20
$
@end example

Si le premier caractère du nom de fichier @code{.output} ou @code{.once}
est le symbole de barre verticale (@code{|}), alors les caractères restants
sont traités comme une commande et la sortie est envoyée à cette
commande.  Cela facilite le transfert des résultats d’une requête vers
un autre processus. Par exemple, la commande @code{open -f} sur un Mac
ouvre un éditeur de texte pour afficher le contenu qu’il lit à partir de
l’entrée standard. Ainsi, pour voir les résultats d’une requête dans un
éditeur de texte, on pourrait taper :

@example
sqlite> .une fois | open -f 
sqlite> SELECT * FROM bigTable;
@end example

Si les commandes @code{.output} ou @code{.once} ont un argument
@code{-e}, alors la sortie est collectée dans un fichier temporaire et
l’éditeur de texte système est invoqué sur ce fichier texte. Ainsi, la
commande @code{.once -e} obtient le même résultat que
@code{.once '|open -f'} mais avec l’avantage d’être portable
sur tous les systèmes.

Si les commandes @code{.output} ou @code{.once} ont un argument
@code{-x}, ce qui les amène à accumuler la sortie sous forme de valeurs
séparées par des virgules (CSV) dans un fichier temporaire,
invoquez l’utilitaire système par défaut pour afficher les fichiers
CSV. (généralement un tableur) sur le résultat. Il s’agit d’un
moyen rapide d’envoyer le résultat d’une requête vers une feuille de
calcul pour une visualisation facile :

@example
sqlite> .once -x 
sqlite> SELECT * FROM bigTable;
@end example

La commande @code{.excel} est un alias pour @code{.once -x}. Cela fait
exactement la même chose.

@c 8.2
@node Lire SQL à partir d’un fichier
@section Lire SQL à partir d’un fichier
@anchor{#reading_sql_from_a_file}

En mode interactif, sqlite3 lit le texte saisi (soit des
instructions SQL, soit des commandes point) à partir du
clavier. Vous pouvez également rediriger les entrées d’un fichier
lorsque vous lancez sqlite3, bien sûr, mais vous n’avez alors
pas la possibilité d’interagir avec le programme.  Parfois, il est utile
d’exécuter un script SQL contenu dans un fichier en saisissant
d’autres commandes à partir de la ligne de commande. Pour cela, la
commande point @code{.read} est fournie.

La commande @code{.read} prend un seul argument qui est (généralement)
le nom d’un fichier à partir duquel lire le texte d’entrée.

@example
sqlite> .read monscript.sql
@end example

La commande @code{.read} arrête temporairement la lecture à partir du
clavier et prend à la place son entrée dans le fichier nommé. Une fois
la fin du fichier atteinte, la saisie revient au clavier. Le fichier de
script peut contenir des commandes point, tout comme une entrée
interactive ordinaire.

Si l’argument de @code{.read} commence par le signe @code{|} , puis au
lieu d’ouvrir l’argument sous forme de fichier, il exécute l’argument
(sans le @code{|}) en tant que commande, puis utilise la sortie de cette
commande comme entrée. Ainsi, si vous disposez d’un script qui génère du
SQL, vous pouvez exécuter ce SQL directement à l’aide
d’une commande similaire à la suivante :

@example
sqlite> .read |monscript.bat
@end example


@c 8.3
@node Fonctions d’E/S sur les fichiers
@section Fonctions d’Entrée/Sortie sur les fichiers
@anchor{#file_i_o_functions}

Le shell de ligne de commande ajoute deux fonctions SQL définies par
l’application qui facilitent respectivement la lecture du contenu d’un
fichier dans une colonne de table et l’écriture du contenu d’une colonne
dans un fichier.

La fonction SQL @code{readfile(X)} lit tout le contenu du
fichier nommé @code{X} et renvoie ce contenu sous forme d’un
@emph{BLOB}. Cela peut être utilisé pour charger du contenu dans un
tableau. Par exemple:

@example
sqlite> CREATE TABLE images(name TEXT, type TEXT, img BLOB);
sqlite> INSERT INTO images(name,type,img)
   ...>   VALUES('icon','jpeg',readfile('icon.jpg'));
@end example

La fonction SQL @code{writefile(X,Y)} écrit le @emph{blob}
@code{Y} dans le fichier nommé @code{X} et renvoie le nombre d’octets
écrits. Utilisez cette fonction pour extraire le contenu d’une seule
colonne de table dans un fichier. Par exemple:

@example
sqlite> SELECT writefile('icon.jpg',img) FROM images WHERE name='icon';
@end example

Notez que les fonctions @code{readfile(X)} et @code{writefile(X,Y)} sont
des extensions qui ne sont pas intégrées à la bibliothèque SQLite
principale. Ces routines sont disponibles sous forme d’extensions
chargeables dans le fichier source @file{ext/misc/fileio.c} qui fait
partie du dépôt source de SQLite.


@c 8.4
@node La fonction SQL edit
@section La fonction SQL edit()
@anchor{#the_edit_sql_function}

L’interface en ligne de commande possède une autre fonction SQL
intégrée nommée @code{edit()}. Cette fonction @code{edit()} prend un ou
deux arguments. Le premier argument est une valeur -- souvent une grande
chaîne multiligne à modifier. Le deuxième argument est l’invocation d’un
éditeur de texte. (Il peut inclure des options pour affecter le
comportement de l’éditeur). Si le deuxième argument est omis, la
variable d’environnement @code{VISUAL} est utilisée. La fonction @code{edit()}
écrit son premier argument dans un fichier temporaire, appelle l’éditeur
sur le fichier temporaire, relit le fichier en mémoire une fois
l’éditeur terminé, puis renvoie le texte modifié.

La fonction @code{edit()} peut être utilisée pour apporter des
modifications à de grandes valeurs de texte. Par exemple:

@example
sqlite> UPDATE docs SET body=edit(body) WHERE name='report-15';
@end example

Dans cet exemple, le contenu du champ @code{docs.body} pour l’entrée où
@code{docs.name} est @code{report-15} sera envoyé à l’éditeur. Après le
retour de l’éditeur, le résultat sera réécrit dans le champ
@code{docs.body}.

L’opération par défaut de la commande @code{edit()} consiste à appeler
un éditeur de texte.  Mais en utilisant un programme d’édition
alternatif dans le deuxième argument, vous pouvez également lui faire
éditer des images ou d’autres ressources non textuelles. Par exemple, si
vous souhaitez modifier une image JPEG qui se trouve être
stockée dans un champ d’une table, vous pouvez exécuter :

@example
sqlite> UPDATE pics SET img=edit(img,'gimp') WHERE id='pic-1542';
@end example

Le programme d’édition peut également être utilisé comme visualiseur, en
ignorant simplement la valeur de retour. Par exemple, pour simplement
regarder l’image ci-dessus, vous pouvez exécuter :

@example
sqlite> SELECT length(edit(img,'gimp')) WHERE id='pic-1542';
@end example


@c 8.5
@node Importation de fichiers au format CSV ou autres formats
@section Importation de fichiers au format CSV ou autres formats
@anchor{#importing_files_as_csv_or_other_formats}

Utilisez la commande @code{.import} pour importer des données
CSV (valeurs séparées par des virgules) ou des données
délimitées de manière similaire dans une table SQLite. La
commande @code{.import} prend deux arguments qui sont la source à partir
de laquelle les données doivent être lues et le nom de la table
SQLite dans laquelle les données doivent être
insérées. L’argument source est le nom d’un fichier à lire ou, s’il
commence par un @code{|} caractère, il spécifie une commande qui sera
exécutée pour produire les données d’entrée.

Notez qu’il peut être important de définir le @code{mode} avant
d’exécuter la commande @code{.import}. Il est prudent d’empêcher le
shell de ligne de commande d’essayer d’interpréter le texte du fichier
d’entrée dans un format autre que la façon dont le fichier est
structuré. Si les options @code{--csv} ou @code{--ascii} sont utilisées,
elles contrôlent les délimiteurs d’entrée d’importation. Dans le cas
contraire, les délimiteurs sont ceux en vigueur pour le mode de sortie
en cours.

Pour importer dans une table ne figurant pas dans le schéma
@code{principal}, l’option @code{--schema} peut être utilisée pour
spécifier que la table se trouve dans un autre schéma. Cela peut être
utile pour les bases de données attachées ou pour importer dans une
table @code{TEMP}.

Lorsque @code{.import} est exécuté, le traitement de la première ligne
d’entrée dépend de l’existence ou non de la table cible. S’il n’existe
pas, le tableau est automatiquement créé et le contenu de la première
ligne de saisie est utilisé pour définir le nom de toutes les colonnes
du tableau. Dans ce cas, le contenu des données du tableau est extrait
de la deuxième ligne d’entrée et des suivantes. Si la table cible existe
déjà, chaque ligne de l’entrée, y compris la première, est considérée
comme le contenu réel des données. Si le fichier d’entrée contient une
ligne initiale d’étiquettes de colonnes, vous pouvez faire en sorte que
la commande .import ignore cette ligne initiale en utilisant l’option
@code{--skip 1}.

Voici un exemple d’utilisation, chargeant une table temporaire
préexistante à partir d’un fichier CSV dont la première ligne
contient des noms de colonnes :

@example
sqlite> .import --csv --skip 1 --schema temp C:/work/data.csv tab1
@end example

Lors de la lecture des données d’entrée dans des modes autres que
@code{ascii}, @code{.import} interprète l’entrée comme des
enregistrements composés de champs conformément à la spécification
@emph{RFC 4180} avec cette exception : l’enregistrement d’entrée et les
séparateurs de champ sont tels que définis par le mode ou par
l’utilisation du Commande @code{.separator}. Les champs sont toujours
sujets à la suppression des guillemets pour inverser les guillemets
effectués conformément à la @emph{RFC 4180}, sauf en mode
ascii.

Pour importer des données avec des délimiteurs arbitraires et sans
guillemets, définissez d’abord le mode ascii (@code{.mode ascii}), puis
définissez les délimiteurs de champ et d’enregistrement à l’aide de la
commande @code{.separator}. Cela supprimera la déquotation. Lors de
@code{.import}, les données seront divisées en champs et enregistrements
selon les délimiteurs ainsi spécifiés.

@c 8.6
@node Exporter au format CSV
@section Exporter au format CSV
@anchor{#export_to_csv}

Pour exporter une table SQLite (ou une partie de table) au format CSV,
définissez simplement le @code{mode} sur @code{csv}, puis exécutez une
requête pour extraire les lignes souhaitées de la table. La sortie sera
formatée au format CSV conformément à la @emph{RFC 4180}.

@example
sqlite> .headers sur 
sqlite> .mode csv 
sqlite> .once c:/work/dataout.csv 
sqlite> SELECT * FROM tab1; 
sqlite> .system c:/work/dataout.csv
@end example

Dans l’exemple ci-dessus, la ligne @code{.headers on} entraîne
l’impression des étiquettes de colonnes comme première ligne de
sortie. Cela signifie que la première ligne du fichier CSV
résultant contiendra des étiquettes de colonnes. Si les étiquettes de
colonnes ne sont pas souhaitées, désactivez plutôt @code{.headers
off}. (Le paramètre @code{.headers off} est le paramètre par défaut et
peut être omis si les en-têtes n’ont pas été préalablement activés.)

La ligne @code{.once FILENAME} fait que toutes les sorties de requête
sont envoyées dans le fichier nommé au lieu d’être imprimées sur la
console. Dans l’exemple ci-dessus, cette ligne entraîne l’écriture du
contenu CSV dans un fichier nommé @file{C:/work/dataout.csv}.

La dernière ligne de l’exemple (le @code{.system c:/work/dataout.csv}) a
le même effet qu’un double-clic sur le fichier
@file{c:/work/dataout.csv} dans Windows. Cela fera généralement
apparaître un tableur pour afficher le fichier CSV.

Cette commande ne fonctionne que telle qu’elle est écrite sous Windows.
La ligne équivalente sur un Mac serait :

@example
sqlite> .system oppen dataout.csv
@end example

Sous Linux et autres systèmes Unix, vous devrez saisir quelque chose
comme :

@example
sqlite> .system xdg-open dataout.csv
@end example

@menu
* Exporter vers Excel::
* Exporter vers TSV::
@end menu


@c 8.6.1
@node Exporter vers Excel
@subsection Exporter vers Excel
@anchor{#_export_to_excel_}

Pour simplifier l’exportation vers une feuille de calcul, l’interface
en ligne de commande fournit la commande @code{.excel} qui capture le
résultat d’une seule requête et envoie ce résultat au tableur par défaut
sur l’ordinateur hôte.  Utilisez-le comme ceci :

@example
sqlite> .excel 
sqlite> onglet SELECT * FROM ;
@end example

La commande ci-dessus écrit le résultat de la requête au format
CSV dans un fichier temporaire, appelle le gestionnaire par
défaut pour les fichiers CSV (généralement le tableur préféré
tel qu’Excel ou LibreOffice), puis supprime le fichier
temporaire. Il s’agit essentiellement d’une méthode abrégée permettant
d’exécuter la séquence de commandes @code{.csv}, @code{.once} et
@code{.system} décrite ci-dessus.

La commande @code{.excel} est en réalité un alias pour @code{.once -x}.
L’option @code{-x} de .once lui permet d’écrire les résultats au
format CSV dans un fichier temporaire nommé avec le suffixe
@code{.csv}, puis d’appeler le gestionnaire par défaut du système pour
les fichiers CSV.

Il existe également une commande @code{.once -e} qui fonctionne de
manière similaire, sauf qu’elle nomme le fichier temporaire avec un
suffixe @code{.txt} afin que l’éditeur de texte par défaut du système
soit invoqué, au lieu de la feuille de calcul par défaut.


@c 8.6.2
@node Exporter vers TSV
@subsection Exporter vers TSV (valeurs séparées par des tabulations)
@anchor{#_export_to_tsv_tab_separated_values_}

L’exportation vers du TSV pur, sans aucune citation de champ,
peut être effectuée en saisir @code{.mode tabs} avant d'exécuter une
requête. Cependant, la sortie sera ne pas être lu correctement en mode
onglets par la commande @code{.import} s'il contient des guillemets
doubles. Pour obtenir le TSV cité selon la @emph{RFC 4180} afin
que il peut être saisi en mode onglets avec @code{.import}, entrez
d'abord @code{.mode@ csv}, puis entrez @code{.separator \t} avant
d'exécuter une requête.

@c 9
@node Accès aux bases sous forme compressée
@chapter Accès aux bases sous forme compressée
@anchor{#accessing_zip_archives_as_database_files}

En plus de lire et d’écrire des fichiers de base de données
SQLite, le Le programme @code{sqlite3} lira et écrira également
les archives ZIP. Simplement spécifier un nom de fichier
d'archive @code{ZIP} à la place d’un nom de fichier de base de données
SQLite sur la ligne de commande initiale, ou dans la commande
@code{.open}, et @code{sqlite3} détectera automatiquement que le fichier
est une archive @code{ZIP} au lieu d’une base de données SQLite
et l’ouvrira comme telle. Ceci fonctionne quel que soit le suffixe du
fichier. Vous pouvez donc ouvrir des fichier @file{JAR}, @file{DOCX} et
@file{ODP} ou tous les autres formats de fichier qui sont sont en
réalité une archive @file{ZIP}.

Une archive @code{ZIP} semble être une base de données contenant une seule
table avec le schéma suivant :

@example
CREATE TABLE zip(
  name,     // Name of the file
  mode,     // Unix-style file permissions
  mtime,    // Timestamp, seconds since 1970
  sz,       // File size after decompression
  rawdata,  // Raw compressed file data
  data,     // Uncompressed file content
  method    // ZIP compression method code
);
@end example

Ainsi, par exemple, si vous vouliez voir l'efficacité de la compression
(exprimée par la taille du contenu compressé par rapport au taille
originale du fichier non compressé) pour tous les fichiers de l'archive
ZIP, trié du plus compressé au moins compressé, vous pouvez exécuter une
requête comme ça:

@example
sqlite> SELECT name, (100.0*length(rawdata))/sz FROM zip ORDER BY 2;
@end example

Ou en utilisant les fonctions d'E/S de fichiers, vous pouvez extraire
des éléments de l'archive ZIP :

@example
sqlite> SELECT writefile(name,content) FROM zip
   ...> WHERE name LIKE 'docProps/%';
@end example


@menu
* Details de l’implémentation de l'accès aux archives ZIP::
@end menu

@c 9.1
@node Details de l’implémentation de l'accès aux archives ZIP
@section Details de l’implémentation de l'accès aux archives ZIP
@anchor{#how_zip_archive_access_is_implemented}

Le shell de ligne de commande utilise la table virtuelle @file{Zipfile} pour
accéder aux archives ZIP. Vous pouvez le voir en exécutant la commande
@code{.schema} lorsqu'une archive @code{ZIP} est ouverte :

@example
sqlite> .schema
CREATE VIRTUAL TABLE zip USING zipfile('document.docx')
/* zip(name,mode,mtime,sz,rawdata,data,method) */;
@end example

Lors de l'ouverture d’un fichier, si le client en ligne de commande
découvre que le fichier est une archive @code{ZIP} au lieu d'une base de
données SQLite, il ouvre en fait une base de données en mémoire, puis
dans cette base de données en mémoire, il crée une instance de la table
virtuelle @file{Zipfile} qui est attachée à l’archive ZIP.

Le traitement spécial pour ouvrir les archives @code{ZIP} est une astuce du
shell de ligne de commande et non de la bibliothèque SQLite. Donc si
vous voulez ouvrir une archive @code{ZIP} comme base de données dans votre
application, vous devrez activer le module de table virtuelle
@code{Zipfile} puis exécuter une instruction @code{CREATE VIRTUAL TABLE}
appropriée.


@c 10
@node Conversion d'une base en fichier texte
@chapter Conversion d'une base en fichier texte
@anchor{#converting_an_entire_database_to_a_text_file}

Utilisez la commande @code{.dump} pour convertir l'intégralité du
contenu d'une base de données dans un seul fichier texte UTF-8. Ce
fichier peut être reconverti en un base de données en la redirigeant
vers @code{sqlite3}.

Une bonne façon de créer une copie d’archive d’une base de données est
la suivante :

@example
$ sqlite3 ex1 .dump | gzip -c >ex1.dump.gz
@end example

Cela génère un fichier nommé @file{ex1.dump.gz} qui contient tout ce
dont vous avez besoin pour reconstruire la base de données
ultérieurement ou sur une autre machine. Pour reconstruire la base de
données, tapez simplement :

@example
$ zcat ex1.dump.gz | sqlite3 ex2
@end example

Le format de texte est du SQL pur, vous pouvez donc également utiliser
la commande @code{.dump} pour exporter une base de données SQLite vers
d'autres moteurs de base de données SQL populaires. Comme ceci:

@example
$ createdb ex2
$ sqlite3 ex1 .dump | psql ex2
@end example


@c 11
@node Récupérer une base de données corrompue
@chapter Récupérer une base de données corrompue
@anchor{#recover_data_from_a_corrupted_database}

Comme la commande @code{.dump}, la commande @code{.recover} tente de
convertir l’intégralité du contenu d’un fichier de la base de données en
texte. La différence est qu’au lieu de lire les données à l’aide de
l’interface de base de données SQL normale, @code{.recover} tente de
réassembler la base de données en fonction des données extraites
directement du plus grand nombre possible de pages de base de
données. Si la base de données est corrompue, @code{.recover} est
généralement capable de récupérer les données de toutes les parties non
corrompues de la base de données, alors que @code{.dump} s’arrête dès
les premiers signes de corruption.

Si la commande @code{.recover} récupère une ou plusieurs lignes qu’elle
ne peut pas attribut à n’importe quelle table de base de données, le
script de sortie crée un Table @code{lost_and_found} pour stocker les
lignes orphelines. Le schéma de la table loss_and_found est la
suivante :

@example
CREATE TABLE lost_and_found(
    rootpgno INTEGER,   -- page racine de l'arbre pgno,
    pgno INTEGER,       -- numéro de page contenant la rangée,
    nfield INTEGER,     -- numéro du champs dans la rangée,
    id INTEGER,         -- valeur du champs rowid, ou NULL
    c0, c1, c2, ...     -- les colonnes des champs de la rangée
);
@end example

La table @code{lost_and_found} contient une ligne pour chaque ligne
orpheline récupérée de la base de données. De plus, il y a une ligne
pour chaque entrée d'index récupérée qui ne peut être attribuée à aucun
index SQL. En effet, dans une base de données SQLite, le même format est
utilisé pour stocker les entrées d'index SQL et SANS les entrées de
table ROWID.

@multitable {c0,@ c1,@ c2...} {Même s'il n'est pas possible d'attribuer la ligne à une} 
@item 
Column
@tab Contenu
@item 
rootpgno
@tab Même s’il n'est pas possible d'attribuer la ligne à une
table de base de données spécifique, elle peut faire partie d'une
structure arborescente au sein de la fichier de base de données. Dans ce
cas, le numéro de page racine de cette arborescence est stocké dans 
cette colonne. Ou, si la page sur laquelle la ligne a été trouvée n'est
pas faisant partie d'une arborescence, cette colonne stocke une copie de
la valeur dans column @code{pgno} - le numéro de page de la page sur
laquelle la ligne a été trouvée. Dans de nombreux cas, mais pas tous,
toutes les lignes de la table loss_and_found avec la même valeur dans
cette colonne appartient à la même table.
@item 
pgno
 @tab Le numéro de la page sur laquelle on trouve cette rangée..
@item 
nfield
 @tab Le nombre de champs dans cette rangée.
@item 
id
 @tab Si la ligne provient d'une table SANS ROWID, cette colonne contient
NUL. Sinon, il contient la valeur entière rowid de 64 bits pour la ligne.
@item 
c0,@ c1,@ c2...
@tab Les valeurs de chaque colonne de la ligne sont stockées dans ces colonnes.
La commande @code{.recover} crée la table loss_and_found avec autant de
colonnes comme requis par la ligne orpheline la plus longue.
@end multitable

Si le schéma de base de données récupéré contient déjà une table nommée
@code{lost_and_found}, la commande @code{.recover} utilise le nom
@code{lost_and_found0}. Si le nom @code{lost_and_found0} est également
déjà pris, @code{lost_and_found1}, et ainsi de suite. Le nom par défaut
@code{lost_and_found} peut être remplacé en appelant @code{.recover}
avec le commutateur @code{--lost-and-found}. Pour exemple, pour que le
script de sortie appelle la table @code{orphaned_rows} :

@example
sqlite> .recover --lost-and-found orphaned_rows
@end example


@c 12
@node Charger des Extensions
@chapter Charger des Extensions
@anchor{#loading_extensions}

Vous pouvez ajouter de nouvelles fonctions SQL personnalisées, des
séquences de classement, des tables virtuelles et VFS vers le shell de
ligne de commande au moment de l’exécution à l’aide de la commande
@code{.load}. D’abord, construire l’extension en tant que DLL ou
bibliothèque partagée (comme décrit dans le Document Extensions
chargeables au moment de l’exécution) puis tapez :

@example
sqlite> .load /path/to/my_extension
@end example

Notez que SQLite ajoute automatiquement le suffixe d’extension approprié
(@code{.dll} sur Windows, @code{.dylib} sur Mac, @code{.so} sur la
plupart des autres Unix) au nom de fichier d’extension. C’est
généralement une bonne idée de préciser l’intégralité chemin d’accès à
l’extension.

SQLite calcule le point d’entrée de l’extension en fonction de l’extension
nom de fichier. Pour remplacer ce choix, ajoutez simplement le nom de l’extension
comme deuxième argument de la commande @code{.load}.

Le code source de plusieurs extensions utiles peut être trouvé dans le
Sous-répertoire @file{ext/misc} de l’arborescence des sources
SQLite. Vous pouvez utiliser ces extensions telles quelles, ou comme
base pour créer votre propre personnalisation extensions pour répondre à
vos propres besoins particuliers.


@c 13
@node Hachages cryptographiques
@chapter Hachages cryptographiques
@anchor{#cryptographic_hashes_of_database_content}

La commande point @code{.sha3sum} calcule un hâchage @emph{SHA3} du
@emph{contenu} de la base de données. Pour être clair, le hâchage est
calculé sur le contenu de la base de données, pas sur sa représentation
sur le disque. Par exemple, ceci signifie qu’un @code{VACUUM} ou une
transformation similaire de préservation des données ne change pas le
hâchage.

La commande @code{.sha3sum} prend en charge les options
@code{--sha3-224}, @code{--sha3-256}, @code{--sha3-384} et
@code{--sha3-512} pour définir la variété de @emph{SHA3} à utiliser pour
le hâchage. La valeur par défaut est @emph{SHA3-256}.

Le schéma de la base de données (dans la table @code{sqlite_schema})
n’est normalement pas inclus dans le hachage, mais peut être ajouté par
l’option @code{--schema}.

La commande @code{.sha3sum} prend un seul argument facultatif similaire
au motif @code{LIKE}. Si cette option est présente, seules les tables
dont les noms correspondent au motif seront hachées.

La commande @code{.sha3sum} est implémentée à l'aide du fonction
d'extension @code{sha3_query()} incluse avec le shell de ligne de
commande.


@c 14
@node Autotests du contenu de la base de données
@chapter Autotests du contenu de la base de données
@anchor{#database_content_self_tests}

La commande @code{.selftest} tente de vérifier si une base de données
est intacte et non corrompue. La commande @code{.selftest} recherche une
table dans le schéma nommé @code{selftest} et définie comme suit :

@example
CREATE TABLE selftest(
  tno INTEGER PRIMARY KEY,  -- Test number
  op TEXT,                  -- 'run’ or 'memo'
  cmd TEXT,                 -- SQL command to run, or text of "memo"
  ans TEXT                  -- Expected result of the SQL command
);
@end example

La commande @code{.selftest} lit les lignes de la table @code{selftest}
en suivant l’ordre @code{selftest.tno}. Pour chaque ligne @code{memo},
il écrit le texte dans @code{cmd} dans le résultat. Pour chaque ligne
inspectée, il exécute l’instruction SQL @code{cmd} et compare le
résultat à la valeur dans @code{ans} et affiche un message d'erreur si
les résultats diffèrent.

S’il n'y a pas de table d’autotest, la commande @code{.selftest} exécute
un pragma de vérification d’intégrité.

La commande @code{.selftest --init} crée la table d’autotest si elle
n’existe pas déjà le cas. Puis elle ajoute des entrées qui vérifient le hachage
SHA3 du contenu de tous les tableaux. Les exécutions ultérieures de
@code{.selftest} vérifieront que la base de données n’a pas été
modifiée. Pour générer des tests pour vérifiez qu’un sous-ensemble des
tables est inchangé, exécutez simplement @code{.selftest --init} puis
supprimez les lignes d’autotest qui font référence aux tables et qui ne
sont pas constantes.


@c 15
@node Prise en charge des archives SQLite
@chapter Prise en charge des archives SQLite
@anchor{#sqlite_archive_support}

La commande @code{.archive} et l'option de ligne de commande @code{-A}"
fournissent une prise en charge intégrée du format d’archive de
SQLite. L’interface est similaire à celui de la commande @code{tar} sur
les systèmes Unix. Chaque invocation de la commande @code{.ar} ne doit
spécifier qu’une seule option. Voici les commandes disponibles pour
@code{.archive} :

@multitable {Option} {Option longue} {Ajoute des fichiers à une archive existante} 
@item Option
 @tab Option longue
 @tab usage
@item @code{-c}
 @tab @code{--create}
 @tab Créé une nouvelle archive contenant le fichier spécifié.
@item @code{-x}
 @tab @code{--extract}
 @tab Extrait le fichier spécifié de l’archive.
@item @code{-i}
 @tab @code{--insert}
 @tab Ajoute des fichiers à une archive existante
@item @code{-r}
 @tab @code{--remove}
 @tab Enlève des fichiers d’une archive.
@item @code{-t}
 @tab @code{--list}
 @tab Liste les fichers de l’archive.
@item @code{-u}
 @tab @code{--update}
 @tab Ajoute des fichiers à une archive existante @emph{s’ils} ont été changés.
@end multitable

En plus de l’option de commande, chaque invocation de @code{.ar} peut
spécifier une ou plusieurs options de modification. Certaines options de
modification nécessitent un argument, d'autres non. Les options de
modification suivantes sont disponibles :

@multitable @columnfractions 0.2 0.2 0.6
@item  Option
 @tab Option_longue
 @tab Usage
@item @code{-v}
 @tab @code{--verbose}
 @tab Liste chaque fichier en cours de traitement.
@item @code{-f FILE}
 @tab @code{--file FILE}
 @tab Si spécifié, utilisez le fichier @file{FILE} comme archive. Sinon,
 supposons que la base de données "principale" (ndt. ``main'') actuelle
 est l'archive à exploiter.
@item @code{-a FILE}
 @tab @code{--append FILE}
 @tab Comme l’option @code{--file}, utilise le fichier @file{FILE} comme
 archive, mais ouvre le fichier en utilisant la VFS @code{apndvfs} pour
 que l’archivage soit ajouté à la fin du fichier @file{FILE} s’il existe.
@item @code{-C DIR}
 @tab @code{--directory DIR}
 @tab Si spécifié, interprète tous les chemins relatifs par rapport à
 @file{DIR}, au lieu d’utiliser le répertoire courant.
@item @code{-g}
 @tab @code{--glob}
 @tab Utilise @code{glob(Y,X)} pour faire correspondre les
 arguments à des noms dans l’archive.
@item @code{-n}
 @tab @code{--dryrun}
 @tab Montre l’instruction SQL, qui devrait être exécutée pour réaliser
 l’opération d’archivage, mais dans les faits ne change rien.
@item @code{--}
 @tab @code{--}
 @tab Tous les mots qui suivent sur la ligne de commande sont des
 arguments de commande, et plus des options.
@end multitable

 Pour une utilisation en ligne de commande, ajoutez les options de ligne
de commande de style court immédiatement après le @code{-A}, sans espace
intermédiaire. Tous les arguments suivants sont considérés comme faisant
partie de la commande @code{.archive}.  Par exemple, les commandes
suivantes sont équivalentes :

@example
sqlite3 new_archive.db -Acv file1 file2 file3
sqlite3 new_archive.db ".ar -cv file1 file2 file3"
@end example

Les options de style long et court peuvent être mélangées. Par exemple,
ces instrucitons sont équivalentes :

@example
-- Deux méthodes pour créer un nouvelle archive "new_archive.db" 
-- contenant les fichiers "file1", "file2" et "file3".
.ar -c --file new_archive.db file1 file2 file3
.ar -f new_archive.db --create file1 file2 file3
@end example

Alternativement, le premier argument suivant @code{.ar} peut être la
concaténation de la forme courte de toutes les options requises (sans le
caractère @code{-}). Dans ce cas, les arguments des options qui les
nécessitent sont lus dans les mots qui suivent sur la ligne de commande,
et tous les mots restants sont compris comme les arguments de commande. Par
exemple:

@example
-- Créé une nouvelle archive "new_archive.db" contenant les fichiers
-- "file1" et "file2" dans le répertoire "dir1".
.ar cCf dir1 new_archive.db file1 file2 file3
@end example


@menu
* La commande de création d’archive (.ar --create)::
* La commande d’extraction (.ar --extract)::
* La commande pour lister le contenu d’une archive (.ar --list)::
* Les commandes pour insérer et mettre à jour (.ar --insert/.ar --update)::
* La commande pour enlever (.ar --remove)::
* Les operations sur les archives ZIP::
* Les Instructions SQL réalisant des opérations d’archivage SQLite::
@end menu


@c 15.1
@node La commande de création d’archive (.ar --create)
@section La commande de création d’archive (.ar --create)
@anchor{#_sqlite_archive_create_command_}

La commande @code{.ar --create} crée une nouvelle archive en écrasant
toute archive existante (soit dans le base de données "principale"
actuelle ou dans le fichier spécifié par une option
@code{--file}). Chaque argument qui suit les options est un fichier à
ajouter à l'archive.  Les répertoires sont importés de manière
récursive. Voir ci-dessus pour des exemples.

@c 15.2
@node La commande d’extraction (.ar --extract)
@section La commande d’extraction (.ar --extract)
@anchor{#_sqlite_archive_extract_command_}

La commande @code{.ar --extract} extrait les fichiers de l’archive (soit
vers le répertoire de travail actuel, soit vers le répertoire spécifié
par une option @code{--directory}). Les fichiers ou les répertoires dont
les noms correspondent aux arguments affectés par l’option @code{--glob}
sont extraits. Si aucun argument ne suit les options, tous les fichiers
et les répertoires sont extraits. Tous les répertoires spécifiés sont
extraits récursivement. C'est une erreur si des noms spécifiés ou des
modèles de recherche ne correspondent à rien dans l’archive.

@example
-- Extrait tous les fichiers de l’archive de la base courante 
-- "main" dans le répertoire courant. Liste les fichiers pendant
-- leur extraction. 
.ar --extract --verbose

-- Extrait le fichier "file1" de l’archive "ar.db" dans le
-- répertoire "dir1".
.ar fCx ar.db dir1 file1

-- Extrait les fichiers avec l’extension ".h" dans le répertoire
-- "headers".
.ar -gCx headers *.h
@end example


@c 15.3
@node La commande pour lister le contenu d’une archive (.ar --list)
@section La commande pour lister le contenu d’une archive (.ar --list)
@anchor{#_sqlite_archive_list_command_}

La commande @code{.ar --list} répertorie le contenu de l’archive. Si aucun
argument n’est spécifié, alors tous les fichiers sont
répertoriés. Sinon, seuls ceux qui correspondent aux arguments de
l’option @code{--glob} sont listés. Actuellement, l’option
@code{--verbose} ne modifie pas le comportement de cette commande. Cela
pourrait changer dans l'avenir.

@example
-- Liste le contenu de l'archive dans la base courante "main"..
.ar --list
@end example


@c 15.4
@node Les commandes pour insérer et mettre à jour (.ar --insert/.ar --update)
@section Les commandes pour insérer et mettre à jour (.ar --insert/.ar --update)
@anchor{#_sqlite_archive_insert_and_update_commands_}


Les commandes @code{.ar --update} et @code{.ar --insert} fonctionnent
comme la commande @code{.ar --create}, sauf qu'ils ne suppriment pas
l’archive courante avant de commencer. Les nouvelles versions des
fichiers remplacent silencieusement les fichiers existants portant les
mêmes noms, mais sinon le contenu initial des archives (le cas échéant)
restent intactes.

Pour la commande @code{.ar --insert}, tous les fichiers répertoriés sont
insérés dans le archive. Pour la commande @code{.ar --update}, les fichiers
ne sont insérés que s'ils ne pré-existent pas dans l'archive, ou que si
leur @code{mtime} ou @code{mode} est différent de ce qui se trouve
actuellement dans l’archive.

Remarque de compatibilité : avant SQLiteversion 3.28.0 (2019-04-16),
seul l’option @code{--update} était prise en charge mais cette option
fonctionnait comme @code{--insert}, car il réinsérait le fichier, qu'il
ait été modifié ou non.


@c 15.5
@node La commande pour enlever (.ar --remove)
@section La commande pour enlever (.ar --remove)
@anchor{#_sqlite_archive_remove_command_}

La commande @code{.ar --remove} supprime les fichiers et les répertoires qui
correspondent aux arguments fournis (le cas échéant) par l'option
@code{--glob}. C'est un erreur de fournir des arguments qui ne
correspondent à rien dans l'archive.


@c 15.6
@node Les operations sur les archives ZIP
@section Les operations sur les archives ZIP
@anchor{#_operations_on_zip_archives_}

Si @file{FILE} est une archive @code{ZIP} plutôt qu’une archive SQLite,
la commande @code{.archive} et l'option de ligne de commande @code{-A}
fonctionnent toujours. C'est réalisé en utilisant l'extension
@url{https://www.sqlite.org/zipfile.html,zipfile}. Les commandes qui
suivent sont à peu près équivalentes et ne diffèrent que par le
format de la sortie :

@multitable {zip -r archive2.zip dir} {Equivalent sqlite3.exe Command} 
@item Traditional Command
 @tab Commande équivalente avec @code{sqlite3.exe}
@item @code{unzip archive.zip}
 @tab @code{sqlite3 -Axf archive.zip}
@item @code{unzip -l archive.zip}
 @tab @code{sqlite3 -Atvf archive.zip}
@item @code{zip -r archive2.zip dir}
 @tab @code{sqlite3 -Acf archive2.zip dir}
@end multitable


@c 15.7
@node Les Instructions SQL réalisant des opérations d’archivage SQLite
@section Les Instructions SQL réalisant des opérations d’archivage SQLite
@anchor{#_sql_used_to_implement_sqlite_archive_operations_}

Les différentes commandes d'archivage de SQLite sont
implémentées à l'aide d’instruction SQL. Les développeurs
d’applications peuvent ajouter simplement un support pour la lecture et
l’écriture des archives SQLite dans leurs projets en utilisant
des instructions SQL approprié.

Pour voir quelles instructions SQL sont utilisées pour
implémenter une archive SQLite opération, ajoutez l’option
@code{--dryrun} ou @code{-n}. Ceci affiche les instructions SQL
affichées mais inhibe leur exécution.

Les instructions SQL implémentant les opérations d’archivage
SQLite utilisent diverses extensions chargeables. Ces
extensions sont toutes disponibles dans l’arborescence des sources de
SQLite dans les sous répertoires de @file{ext/misc/}. Les
extensions nécessaires à la prise en charge complète de l'archivage
SQLite incluent:


@enumerate 
@item fileio.c
--- Cette extension ajoute les fonctions SQL @code{readfile()}
et @code{writefile()} pour lire et écrire à partir de fichiers présents
sur le disque. L’extension @file{fileio.c} inclut également la fonction
@code{fsdir()} pour répertorier le contenu d’un répertoire et la
fonction @code{lsmode()} qui convertit les codes numérique
@code{st_mode} de l’appel système @code{stat()} en chaînes lisibles par
l’homme après, à la manière de la commande @code{ls -l}.

@item sqlar.c 
--- Cette extension ajoute les fonctions @code{sqlar_compress()} et
@code{sqlar_uncompress()} nécessaires pour compresser et décompresser un
fichier au fur et à mesure de son extraction d’une archive SQLite.

@item zipfile.c
--- Cette extension implémente la fonction @code{zipfile(FILE)} qui est
utilisée pour lire les archives @code{ZIP}. Cette extension n'est
nécessaire que pour lire les archives @code{ZIP} au lieu des archives
SQLite.

@item appendvfs.c
--- Cette extension implémente un système de fichiers virtuel
(VFS) supplémentaire qui permet d’ajouter une base de données
SQLite à un autre fichier, comme un exécutable. Cette extension
n’est nécessaire que si l'option @code{--append} de la commande
@code{.archive} est utilisée.

@end enumerate

@c 16
@node Paramètres SQL
@chapter Paramètres SQL
@anchor{#sql_parameters}

@code{SQLite} permet aux paramètres liés d’apparaître dans une
instruction SQL partout où une valeur littérale est
permise. Les valeurs de ces les paramètres sont définis à l’aide de la
famille d’API @code{sqlite3_bind_...()}.

Les paramètres peuvent être nommés ou non. Un paramètre sans nom est un
un point d'interrogation seul (@code{?}). Les paramètres nommés sont un
@code{?} suivis immédiatement par un chiffre (ex : @code{?15} ou
@code{?123}) ou un des caractères @code{$}, @code{:}, ou @code{@@} suivi
d’un nom alphanumérique (ex : @code{$var1}, @code{:xyz}, @code{@@bingo}).

Ce shell en ligne de commande laisse les paramètres sans nom détachés,
ce qui signifie qu’ils auront une valeur SQL @code{NULL}. Par
contre, les paramètres nommés auront des valeurs assignées. S’il existe
une table @code{TEMP} nommée @code{sqlite_parameters} avec un schéma
comme celui-ci :

@example
CREATE TEMP TABLE sqlite_parameters(
  key TEXT PRIMARY KEY,
  value
) WITHOUT ROWID;
@end example

Et s'il y a une entrée dans cette table où la colonne des identifiants
correspond exactement au nom du paramètre (comprenant les initiales
@code{?}, @code{$}, @code{:} ou le caractère @code{@@}), le paramètre
reçoit alors la valeur de la colonne des valeurs correspondantes. Si
aucune entrée n’existe, le paramètre par défaut est @code{NULL}.

La commande @code{.parameter} existe pour simplifier la gestion de cette
table. La commande @code{.parameter init} (souvent abrégée en
@code{.param init}) crée la table @file{temp.sqlite_parameters} si elle
n’existe pas déjà.  La commande @code{.param list} affiche toutes les
entrées de la table @code{temp.sqlite_parameters}. La commande
@code{.param clear} supprime le table @code{temp.sqlite_parameters}. Les
commandes @code{.param set CLÉ VALEUR} et @code{.param unset CLÉ}
créent ou suppriment des entrées du table @code{temp.sqlite_parameters}.

La @code{VALEUR} transmise à @code{.param set CLÉ VALEUR} peut être soit
un littéral SQL ou toute autre expression ou requête
SQL qui peut être évaluée pour générer une valeur. Ceci permet
de définir des valeurs de différents types. Si ce genre d’évaluation
échoue, la @code{VALEUR} fournie est mise sous guillemets et insérée
comme un texte. Parce qu'une telle évaluation peut échouer en fonction
du contenu de la @code{VALEUR}, le moyen fiable d’obtenir une valeur de
texte est de l’entourer avec des guillemets simples qui la protègeront
pendant l’analyse décrite ci-dessous. Par exemple, (sauf si l'on
souhaite une valeur de -1365) :

@example
.parameter init
.parameter set @@phoneNumber "'202-456-1111'"
@end example

Notez que les guillemets doubles servent à protéger les guillemets
simples et de s'assurer ainsi que le texte cité est analysé comme un
seul argument.

La table @code{temp.sqlite_parameters} fournit uniquement des valeurs
pour les paramètres dans le shell de la ligne de commande. La table
@code{temp.sqlite_parameter} n’a aucun effet sur requêtes exécutées
directement à l’aide de l’API SQLite du langage C. Les
applications individuelles sont censées implémenter leur propres
paramètres obligatoires. Vous pouvez rechercher @code{sqlite_parameters}
dans le code source de l’interface en ligne de commande de
SQLite pour voir comment l’interface en ligne de commande
établit la liaison avec les paramètres pour l’utiliser comme guide pour
les implémenter dans vos propres applications.

@c 17
@node Recommendation pour les experts SQLite sur les index
@chapter Recommendation pour les experts SQLite sur les index
@anchor{#index_recommendations_sqlite_expert_}

Note: This command is experimental. It may be removed or the
interface modified in incompatible ways at some point in the future.

Pour la plutpart des bases de données non triviales, la clé pour une
bonne performance est de créer les bons index. Dans ce contexte,
les « bons index SQL » signifient ceux qui feront que les requêtes
demandées par une application seront rapides. La commande @code{.expert}
peut aider à définir les meilleurs index pour une requête spécifique, si
elles sont présentes dans la base de données.

La commande @code{.expert} est utilisée dans un premier temps, suivie de
la requète SQL sur une ligne séparée. Par exemple, considérez
la session suivante :

@example
sqlite> CREATE TABLE x1(a, b, c);
sqlite> .expert
sqlite> SELECT * FROM x1 WHERE a=? AND b>?;
CREATE INDEX x1_idx_000123a7 ON x1(a, b);

0|0|0|SEARCH TABLE x1 USING INDEX x1_idx_000123a7 (a=? AND b>?)

sqlite> CREATE INDEX x1ab ON x1(a, b);     
sqlite> .expert
sqlite> SELECT * FROM x1 WHERE a=? AND b>?;
(no new indexes)

0|0|0|SEARCH TABLE x1 USING INDEX x1ab (a=? AND b>?)
@end example

Dans l’exemple ci-dessus, l’utilisateur crée un schéma de base de
données (une table simple @code{x1}) et ensuite utilise la commande
@code{.expert} pour analyser une requête, dans cas @code{"SELECT * FROM
x1 WHERE a=? AND b>?"}. L’outil shell recommande alors que l’utilisateur
crée un nouvel index (index @code{"x1_idx_000123a7}) et sort le plan que
la requète utiliserait avec le format @code{EXPLAIN QUERY
PLAN}. L’utilisateur crée alors un index équivalent avec un schéma
équivalent et lance l’analyse de nouveau sur la même requète. Cette
fois, l’outil shell ne recommande par un nouvel index et renvoie les
plan que SQLite va utiliser pour cette requète en utilisant
l’index donné.

La commande @code{.expert} accepte les options suivantes :

@multitable @columnfractions .2 .8
@item Option
 @tab Objet
 
@item
@code{--verbose}
 @tab Si présent, la sortie donnera un rapport plus verveux pour chaque
 requète analysée.
 
@item 
@code{--sample POURCENT}
@tab Ce paramètre à 0 comme valeur par défaut, ce qui fait que la
 command @code{.expert} ne recommande que des index basés sur des
 requètes et le schéma de base données. Ce paramètre est par défaut à 0,
 ce qui fait que la commande @code{.expert} recommande des index basés
 uniquement sur la requête et le schéma de la base de données. Ceci est
 similaire à la façon dont le planificateur de requêtes SQLite
 sélectionne les index pour les requêtes si l’utilisateur n’a pas
 exécuté la commande @code{ANALYZE} sur la base de données pour générer
 des statistiques de distribution des données. Si cette option reçoit un
 argument non nul, la commande @code{.expert} génère des statistiques de
 distribution de données similaires pour tous les index considérés,
 basées sur un pourcentage (@code{PERCENT}) des lignes actuellement
 stockées dans chaque table de la base de données. Pour les bases de
 données avec des distributions de données inhabituelles, cela peut
 conduire à de meilleures recommandations d’index, en particulier si
 l’application prévoit d’exécuter @code{ANALYZE}. Pour les petites bases
 de données et les processeurs modernes, il n’y a généralement aucune
 raison de ne pas passer "@code{--sample 100}". Cependant, la collecte
 de statistiques de distribution des données peut être coûteuse pour les
 grandes tables de base de données. Si l’opération est trop lente,
 essayez de passer une valeur plus petite pour l’option @code{--sample}.
@end multitable

La fonctionnalité décrite dans cette section peut être intégrée dans
d’autres applications ou outils en utilisant le code d’extension
SQLite expert.

Un schéma de base de données qui incorpore des fonctions SQL
personnalisées disponibles via le mécanisme de chargement d’extension
peut nécessiter des dispositions spéciales pour fonctionner avec la
fonctionnalité @code{.expert}. Étant donné que cette fonctionnalité
utilise des connexions supplémentaires pour implémenter ses
fonctionnalités, ces fonctions personnalisées doivent être rendues
disponibles pour ces connexions supplémentaires. Cela peut être fait
grâce aux options de chargement/utilisation d’extension décrites dans
les sections Chargement Automatique des Extensions Liées Statiquement et
Extensions Chargeables Persistantes.

@c 18
@node Travailler avec des connexions multiples à base de données
@chapter Travailler avec des connexions multiples à base de données
@anchor{#working_with_multiple_database_connections}

À partir de la version 3.37.0 (27-11-2021), l’interface en ligne de
commande a la capacité de maintenir plusieurs connexions de bases
de données ouvertes en même temps. Une seule connexion de base de
données est active à la fois. Les connexions inactives restent ouvertes
mais sont en attente.

Utilisez la commande point @code{.connection} (souvent abrégée en
@code{.conn}) pour voir une liste des connexions de bases de données et
une indication de laquelle est actuellement active. Chaque connexion de
base de données est identifiée par un entier entre 0 et 9. (Il peut y
avoir au maximum 10 connexions ouvertes simultanément.) Passez à une
autre connexion de base de données, en la créant si elle n’existe pas
déjà, en tapant la commande @code{.conn} suivie de son numéro. Fermez
une connexion de base de données en tapant @code{.conn close N} où
@code{N} est le numéro de la connexion.

Bien que les connexions de bases de données SQLite
sous-jacentes soient complètement indépendantes les unes des autres, de
nombreux paramètres de l’interface en ligne de commande, tels que le
format de sortie, sont partagés entre toutes les connexions de bases de
données. Ainsi, changer le mode de sortie dans une connexion le changera
dans toutes. En revanche, certaines commandes point, comme @code{.open},
n’affectent que la connexion actuelle.


@c 19
@node Fonctionalités diverses de l’extension
@chapter Fonctionalités diverses de l’extension
@anchor{#miscellaneous_extension_features}


L’interface en ligne de commande est construit avec plusieurs extensions
@code{SQLite} qui ne sont pas incluses avec la bibliothèque
@code{SQLite}. Quelques-unes ajoutent des fonctionnalités non décrites dans les
sections précédentes, à savoir :

@itemize
@item
la séquence de collation @code{UINT} qui traite les entiers non signés
intégrés dans du texte selon leur valeur, ainsi que d'autres textes,
pour le tri ;
@item
l'arithmétique décimale fournie par l'extension @code{decimal} ;
@item
les @code{generate_series()} de la fonction @code{table-valued};
@item
les fonctions @code{base64()} et @code{base85()} qui encodent un blob en
texte @emph{base64} ou @emph{base85}, ou décodent le même en blob ;
@item
le support des expressions régulières étendues POSIX liées à
l'opérateur @code{REGEXP}.
@end itemize


@c 20
@node Autres commandes point
@chapter Autres commandes point
@anchor{#other_dot_commands}

Il y a beaucoup d’autres commandes point disponibles dans le shell en
ligne de commande. Voir la commandes @code{.help} pour une liste
complète pour toutes les versions de SQLite.


@c 21
@node Utiliser sqlite3 dans un script shell
@chapter Utiliser sqlite3 dans un script shell
@anchor{#using_sqlite3_in_a_shell_script}

Une façon d'utiliser @code{sqlite3} dans un script shell consiste à
utiliser @code{echo} ou @code{cat} pour générer une séquence de
commandes dans un fichier, puis appeler @code{sqlite3} pendant rediriger
l'entrée du fichier de commande généré. Cela fonctionne bien et est
approprié dans de nombreuses circonstances. Mais pour plus de commodité,
sqlite3 permet de saisir une seule commande SQL sur la ligne de
commande comme un deuxième argument après le nom de la base de
données. Lorsque le programme @code{sqlite3} est lancé avec deux arguments, le
deuxième argument est passé au SQLitebibliothèque pour le traitement,
les résultats de la requête sont imprimés sur la sortie standard en mode
liste et le programme se termine. Ce mécanisme est conçu pour faire
sqlite3 facile à utiliser avec des programmes comme @code{awk}. Pour
exemple:

@example
$ sqlite3 ex1 'select * from tbl1' \
>  | awk '@{printf "<tr><td>%s<td>%s\n",$1,$2 @}'
<tr><td>hello<td>10
<tr><td>goodbye<td>20
$
@end example


@c 22
@node Marquer la fin d’une instruction SQL
@chapter Marquer la fin d’une instruction SQL
@anchor{#marking_the_end_of_an_sql_statement}

Les commandes SQLite sont normalement terminée par un point
virgule. Dans l’interface en ligne de commande, vous pouvez aussi
utiliser le mot @code{GO} (insensible à la casse) ou la barre oblique
@code{/} sur une ligne pour terminer une commande. Ces caractères sont
utilisés par, respectivement, SQL Server et Oracle et
ils sont supporté par l’interface en ligne de commande de
SQLite pour des raisons de compatibilités. Ceci ne fonctionne
pas avec sqlite3_exec(), car l’interface en ligne de commande
traduit ces entrées en point virgules avant des les envoyer au cœur
d'exécution de @code{SQLite}.


@c 23
@node Options de la ligne de commandes
@chapter Options de la ligne de commandes
@anchor{#command_line_options}

Il y a beaucoup d’optiopns pour les commandes de l’interface
shell. Utilisez la commande @code{--help} pour en avoir la liste :

@example
$ sqlite3 --help
Usage: ./sqlite3 [OPTIONS] FILENAME [SQL]
FILENAME is the name of an SQLite database. A new database is created
if the file does not previously exist. Defaults to :memory:.
OPTIONS include:
   --                   treat no subsequent arguments as options
   -A ARGS...           run ".archive ARGS" and exit
   -append              append the database to the end of the file
   -ascii               set output mode to 'ascii'
   -bail                stop after hitting an error
   -batch               force batch I/O
   -box                 set output mode to 'box'
   -column              set output mode to 'column'
   -cmd COMMAND         run "COMMAND" before reading stdin
   -csv                 set output mode to 'csv'
   -deserialize         open the database using sqlite3_deserialize()
   -echo                print inputs before execution
   -init FILENAME       read/process named file
   -[no]header          turn headers on or off
   -help                show this message
   -html                set output mode to HTML
   -interactive         force interactive I/O
   -json                set output mode to 'json'
   -line                set output mode to 'line'
   -list                set output mode to 'list'
   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory
   -markdown            set output mode to 'markdown'
   -maxsize N           maximum size for a --deserialize database
   -memtrace            trace all memory allocations and deallocations
   -mmap N              default mmap size set to N
   -newline SEP         set output row separator. Default: '\n'
   -nofollow            refuse to open symbolic links to database files
   -nonce STRING        set the safe-mode escape nonce
   -nullvalue TEXT      set text string for NULL values. Default ''
   -pagecache SIZE N    use N slots of SZ bytes each for page cache mem
   -pcachetrace         trace all page cache operations
   -quote               set output mode to 'quote'
   -readonly            open the database read-only
   -safe                enable safe-mode
   -separator SEP       set output column separator. Default: '|'
   -stats               print memory stats before each finalize
   -table               set output mode to 'table'
   -tabs                set output mode to 'tabs'
   -unsafe-testing      allow unsafe commands and modes for testing
   -version             show SQLite version
   -vfs NAME            use NAME as the default VFS
   -zip                 open the file as a ZIP Archive
@end example

L’interface en ligne de commande est flexible pour ce qui concerne le
formattage des options. On peut mettre un ou deux caractères @code{-} en
préfixe. Donc @code{-box} et @code{--box} signifie la même chose. Les
options en ligne de commande sont traitées de gauche à droite. Donc une
option @code{--box} remplacera une option @code{--quote} qui la
précèderait.

La plupart des options en lignes de commandes s'expliquent par elles
mêmes, mais certaines méritent quelques explications supplémentaires
ci-après.

@menu
* L’option de ligne de commande --safe::
* L’option de ligne de commande --unsafe-testing::
* Les options de ligne de commande --no-utf8 et --utf8::
@end menu

@c 23.1
@node L’option de ligne de commande --safe
@section L’option de ligne de commande @code{--safe}
@anchor{#the_safe_command_line_option}

L’option de ligne de commande @code{safe} tente de désactiver toutes les
fonctionnalités du CLI pouvant entraîner des modifications sur
l’ordinateur hôte autres que des modifications au fichier de base de
données spécifique nommé sur la ligne de commande. L’idée est que si
vous recevez un gros script SQL d'un inconnu ou non fiable source, vous
pouvez exécuter ce script pour voir ce qu'il fait sans risquer de
exploiter en utilisant l’option @code{safe}. L’option @code{safe}
désactive (parmi autres choses):

@itemize
@item
La commande @code{.open}, sauf is l’option @code{--hexdb} est utilisée
ou si le nom du fichier est @code{:memory:}. This prevents the script
from reading or writing any database files not named on the original
command-line. Cela empêche le script de lire ou d'écrire des fichiers de
base de données non nommés sur la ligne de commande d'origine.
@item
La commande SQL @code{ATTACH}.
@item
Les fonctions SQL qui peuvent potentiellement avoir des effets
de bord dangereux comme @code{edit()}, @code{fts3_tokenizer()},
@code{load_extension()}, @code{readfile()} and @code{writefile()}.
@item
La commande @code{.archive}.
@item
Les commandes @code{.backup} et @code{.save}.
@item
La commandes @code{.import}.
@item
La commande @code{.load}.
@item
La commande @code{.log}.
@item
Les commandes @code{.shell} et @code{.system}.
@item
Les commandes @code{.excel}, @code{.once} et @code{.output}.
@item
Les autres commandes qui peuvent avoir des effets de bords délétères.
@end itemize

En pratique, toutes les fonctionnalités de l’interface en ligne de
commande qui lisent ou écrivent à partir d’un fichier sur un disque
autre que le fichier de base de données principal sont désactivé.


@menu
* Court-circuiter des commandes particulières avec --safe restrictions::
@end menu

@c 23.1.1
@node Court-circuiter des commandes particulières avec --safe restrictions
@subsection Court-circuiter des commandes particulières avec --safe restrictions
@anchor{#bypassing_safe_restrictions_for_specific_commands}

Si l'option @code{--nonce NONCE} est également incluse sur la ligne de
commande, par exemple une chaîne @code{NONCE} volumineuse et arbitraire,
puis la commande @code{.nonce NONCE} (avec la même grande chaîne
occasionnelle) autorisera la prochaine instruction SQL ou
commande point pour contourner les restrictions @code{--safe}.

Supposons que vous souhaitiez exécuter un script suspect et que celui-ci
nécessite une ou deux des fonctionnalités que @code{--safe désactive}
normalement. Par exemple, supposons qu'il doive ATTACHER une base de
données supplémentaire. Ou supposons que Le script doive charger une
extension spécifique. Ceci peut être accompli en précédant l’instruction
ATTACH (soigneusement vérifiée) ou la commande @code{.load} avec une
commande @code{.nonce} appropriée et en fournissant la même valeur
occasionnelle à l'aide de l'option en ligne de commande
@code{--nonce}. Ces commandes spécifiques seront alors autorisées à
s'exécuter normalement, mais toutes les autres commandes dangereuses
seront toujours restreintes.

L’utilisation de @code{.nonce} est dangereuse car une erreur peut
permettre à un script hostile d’endommager votre système. Par
conséquent, n’utilisez @code{.nonce} qu’avec précaution, parcimonie, et
en dernier recours lorsqu’il n'existe pas d'autres moyens d'obtenir un
script à exécuter en mode @code{--safe}.


@c 23.2
@node L’option de ligne de commande --unsafe-testing
@section L’option de ligne de commande --unsafe-testing
@anchor{#the_unsafe_testing_command_line_option}

L’option de ligne de commande @code{--unsafe-testing} permet d’utiliser
l’interface en ligne de commande pour des tests internes de la
bibliothèque SQLite. Ce n’est ni nécessaire ni utile pour
l’utiliser en utilitaire pour créer, modifier ou interroger des bases de
données SQLite. Il est prévu pour permettre des tests de
scripts avec des changements de schéma, des défaites des mesures
défensives et certains commandes point à usage spécial, non
documentées.

Une mauvaise utilisation qui nécessiterait l’utilisation de l’option
@code{--unsafe-testing} ne sera généralement pas considéré comme un
boggue pour cette seule raison.  Le comportement de la lgine de commande
avec @code{--unsafe-testing} n'est ni pris en charge ni défini.


@c 23.3
@node Les options de ligne de commande --no-utf8 et --utf8
@section Les options de ligne de commande --no-utf8 et --utf8
@anchor{#the_no_utf8_and_utf8_command_line_options}

Sur la plateforme Windows, lorsque la console est utilisée en entrée ou
en sortie, une traduction est requise entre l'encodage de caractères
disponible dans la console et à la représentation textuelle @emph{UTF-8}
interne à l’interface en ligne de commande. Les versions précédentes
acceptaient ces options pour activer ou désactiver l’utilisation d’une
traduction qui reposait sur une fonctionnalité de la console Windows
grâce à laquelle elle pourrait être amené à produire ou à accepter
@emph{UTF-8} sur les versions modernes du système d'exploitation.

Les versions actuelles de l’interface (3.44.1 ou ultérieures) effectuent
les E/S de la console en lisant ou en écrivant UTF-16 depuis/vers les
API de la console Windows. Parce que cela fonctionne correctement même
sur les versions de Windows remontant à Windows 2000, il y a plus besoin
de ces options. Ils sont toujours acceptés, mais sans effet.

Dans tous les cas, les E/S texte hors console sont codées en UTF-8.

Sur les plateformes non Windows, ces options sont également ignorées.

@c 24
@node Compiler le programme sqlite3 depuis ses sources
@chapter Compiler le programme sqlite3 depuis ses sources
@anchor{#compiling_the_sqlite3_program_from_sources}

La commande de compilation en ligne de commande sur un shell sur les
système Unix ou Windows avec MinGW fonctionne
avec les commandes habituelles @code{configure/make} :

@example
sh configure; make
@end example

Cette commande @code{configure/make} fonctionne que vous bâtissiez le
programme de l’arbre des sources canonique oubien d’un paquet
fusionné. Il y a quelque dépendances. Quand on compile à partir des
sources canonique, une installation opérationnelle de @code{tclsh} est
requise. Si vous utilisez un paquet fusionné, toutes les tâches amont
faites normalement avec @code{tclsh} auront déjà été faite et seulement
les outils normaux sont requis.

Un bibliothèque de compression @code{zlib} est nécessaire pour que la
commande @code{.archive} puisse opérer.

Sous Windows avec @code{MSVC}, utilisez @code{nmake} avec le
fichier @file{ Makefile.msc} :

@example
nmake /f Makefile.msc
@end example

Pour un fonctionnement correct avec la commande @code{.archive}, faites
une copie du code source @code{zlib} dans le sous-répertoire
@file{compat/zlib} de l'arbre des sources et compiler de la manière
suivante :

@example
nmake /f Makefile.msc USE_ZLIB=1
@end example

@menu
* Tout compiler par soi-même::
@end menu

@c 24.1
@node Tout compiler par soi-même
@section Tout compiler par soi-même
@anchor{#_do_it_yourself_builds_}

Le code source de l’interface de ligne de commande @code{sqlite3} se
trouve dans un seul fichier nommé @code{shell.c}. Le fichier source
@file{shell.c} est généré à partir d’autres sources, mais la plupart du
code de @code{shell.c} se trouve dans @file{src/shell.c.in}. (Régénérez
@code{shell.c} en tapant @code{make shell.c} à partir de l’arborescence des
sources canoniques.)  Compilez le fichier @code{shell.c} (avec le code source
de la bibliothèque @code{sqlite3} ) pour générer l’exécutable. Par exemple:

@example
gcc -o sqlite3 shell.c sqlite3.c -ldl -lpthread -lz -lm
@end example

Les options de compilation supplémentaires suivantes sont recommandées
afin de fournir un shell de ligne de commande complet :

@itemize
@item
-DSQLITE_THREADSAFE=0
@item
-DSQLITE_ENABLE_EXPLAIN_COMMENTS
@item
-DSQLITE_HAVE_ZLIB
@item
-DSQLITE_INTROSPECTION_PRAGMAS
@item
-DSQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
@item
-DSQLITE_ENABLE_STMTVTAB
@item
-DSQLITE_ENABLE_DBPAGE_VTAB
@item
-DSQLITE_ENABLE_DBSTAT_VTAB
@item
-DSQLITE_ENABLE_OFFSET_SQL_FUNC
@item
-DSQLITE_ENABLE_JSON1
@item
-DSQLITE_ENABLE_RTREE
@item
-DSQLITE_ENABLE_FTS4
@item
-DSQLITE_ENABLE_FTS5
@end itemize

@emph{La page source date du 2024-04-16, la traduction du 2024-04-24}

@bye
